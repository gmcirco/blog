{
  "hash": "cba6cf2b7e6a3b7e0dd9be2d0fcc2d59",
  "result": {
    "markdown": "---\ntitle: \"Creating Synthetic Spatial Data\"\nsubtitle: \"Simulating Gas Stations and Robberies\"\nauthor: \"Gio Circo, Ph.D.\"\ndate: 2024-6-15\ncategories:\n  - R\n  - Synthetic Data\nformat: \n    html:\n        self-contained: true\n        code-fold: true\n        mainfont: \"Roboto\"\n        section-divs: true\n        toc: true\n        title-block-banner: true\neditor: visual\ntheme: flatly\nimage: \"map-gas.png\"\n---\n\n\n\n\n## Synthetic Data\n\nIn my work as a data scientist I have been working increasingly more with synthetic data generation. Synthetic data can be very useful when you are working on products that need reasonable stand-in values to test deployment. For example, a common issue I see is that a team needs data to populate a SQL table so they can populate a demo dashboard. Many times waiting for real data will take too long and unnecessarily stretch out the development time.\n\nNow, when we talk about generating synthetic data we're talking about more than just inserting random values into a table. Good synthetic data should mirror the properties of the original (or the properties of some pre-defined requirements).\nFor example, you may want to have an age and race field that match the same \ndemographics of the U.S. Census. Or you might need the relationship between two\nfields to be consistent - like a medical procedure field matched with a cost\nfield.\n\nAn interesting question I posed to myself was \"What if I wanted to generate synthetic *spatial* data?\" This is an interesting question, because spatial data need to have additional properties matched. Of course if we want to simulate crimes in a city, we can't just randomly throw points on the map. Crime does [not occur randomly](https://onlinelibrary.wiley.com/doi/full/10.1111/1745-9125.12070), and so if we want to simulate realistic processes, we need methods that generate them accurately.\n\n### Simulating Crime at Gas Stations\n\nMy idea here is to try and simulate many different realizations of gas station locations in the region. We don't necessarily care if they exactly match a *real* location, but we care more about the intensity of the pattern. The data I'm using is some Hartford crime data that I collected for my [quickGrid](https://github.com/gmcirco/quickGrid) package.\n\nBelow is the locations of gas stations (blue) and robbery incidents (red). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot robbery ~ gas\nggplot() +\n  geom_sf(data = hartford, fill = 'grey90', color = 'white') +\n  geom_sf(data = robbery, color = \"#EE6677\", size = 1, alpha = .5) +\n  geom_sf(data = gas, color = \"#4477AA\", size = 2) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![Robberies and gas stations, Hartford CT (2017)](spatial-sim_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nWhat we want to do is take this information and simulate, many times, different synthetic realizations of this pattern (gas stations and robberies). In practice we could use these simulated datasets to test a statistical method, populate some dashboard or map using de-identified data, or as a step in generating some new model.\n\n## Simulating Gas Station Locations\n\nFor this example we'll start with gas stations. Ideally we want to simulate an [Inhomogeneous Poisson point process](https://en.wikipedia.org/wiki/Poisson_point_process#Inhomogeneous_Poisson_point_process). In simple terms, this means that the intensity of the point pattern $lambda$ is not constant across the study region. Logically this makes sense because gas stations are typically confined to commercial areas and don't appear randomly in the middle of parks or waterways. \n\nIn R this is easy to do. We can calculate the intensity of gas station locations by computing the kernel density of observed locations, and then use those density values as input for our simulation. We can do the same for robberies as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert to ppp for spatial stuff\nhartford_sp <- as.owin(hartford)\n\ngas_ppp <- as.ppp(gas, W = hartford_sp)\nmarks(gas_ppp) <- \"gas\"\n\nrobbery_ppp <- as.ppp(robbery, W = hartford_sp)\nmarks(robbery_ppp) <- \"robbery\"\n\ngas_robbery_ppp <- superimpose(gas_ppp, robbery_ppp, W = hartford_sp)\nmarks(gas_robbery_ppp) <- factor(marks(gas_robbery_ppp))\n\n\n# calculate the density of gas stations & robberies\n# replace negative values with 0\ngas_density <- density.ppp(gas_ppp, sigma = 750)\ngas_density[gas_density < 0] <- 0\n\nrobbery_density <- density.ppp(robbery_ppp, sigma = 500)\nrobbery_density[robbery_density < 0] <- 0\n```\n:::\n\n\nWe can plot the density of gas station locations. In this case the density values are based on points per unit (so gas stations per square foot).\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(gas_density, main = \"Gas Station Density\")\n```\n\n::: {.cell-output-display}\n![Kernel density estimate of gas stations](spatial-sim_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(robbery_density, main = \"Robbery Density\")\n```\n\n::: {.cell-output-display}\n![Kernel density estimate of robberies](spatial-sim_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n:::\n\n\n### Calculating K-function\n\nAs we simulate the position of gas stations in the city, we will want to make sure they are relatively consistent with the patterns observed in reality. For example: we wouldn't expect all 50ish gas stations to be right on top of each other - nor would we expect to see them scattered randomly. What we can do is compute the clustering intensity of the observed point pattern, and then compare that to our simulations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN_SIM <- 100\nN_GAS <- nrow(gas)\n\n# observed K-function for gas stations\ngas_kest <- Kest(gas_ppp)\n\n# simulate gas stations\n# generate 100 simulations\ngas_sim <- rpoispp(gas_density,nsim = N_SIM)\nrobbery_sim <- rpoispp(robbery_density, nsim = N_SIM)\n```\n:::\n\n\nThis gives us the observed K function for gas stations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(gas_kest)\n```\n\n::: {.cell-output-display}\n![](spatial-sim_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nNow we can simulate. So we're going to take the observed density values as probabilities for an inhomogeneous Poisson point process. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# simulate gas stations\n# generate 100 simulations\ngas_sim <- rpoispp(gas_density,nsim = N_SIM)\n\n# get N gas stations generated\n# and intensity of generated function\nsim_N <- sapply(gas_sim, function(x){as.numeric(x$n) })\nsim_L <- lapply(gas_sim, Kest, correction = \"border\", r = gas_kest$r)\n\n# plot envelopes against observed\nX <- sapply(sim_L, function(x){x$border})\n\nXdf <- as.data.frame(X)\nXdf$r <- gas_kest$r\n\n\n# Plot observed K against simulations of K\nobs_K <- data.frame(r = gas_kest$r,\n                    K = gas_kest$border)\n```\n:::\n\n\nThis plots the minimum and maximum envelopes (in grey) of the simulations against the observed K values in red. In general, we see that the pairwise relationships between gas stations is fairly close to observed, expect at small spatial scales. We appear to be failing to simulate cases where many gas stations are near each other (such as at 4 way intersections with a station on each corner). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nXdf %>%\n  pivot_longer(-r, names_to = \"simulation\", values_to = \"K\") %>%\n  group_by(r) %>%\n  summarise(Kmin = min(K),\n            Kmax = max(K)) %>%\n  ggplot() +\n  geom_ribbon(aes(x = r, ymin = Kmin, ymax = Kmax), alpha = .3) +\n  geom_line(data = obs_K, aes(x = r, y = K), linewidth = 1, color = 'red') + \n  labs(y = 'K(Border)', x = 'Distance (feet)') +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![100 Simulation envelopes (grey) compared to observed K (red)](spatial-sim_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nWe can also plot the points directly and see what they look like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| warning: false\nsim_gas_points <-\n  st_as_sf(\n    data.frame(x = gas_sim$`Simulation 10`$x, y = gas_sim$`Simulation 10`$y),\n    coords = c(\"x\", \"y\")\n  ) %>%\n  `st_crs<-`(. , st_crs(gas))\n\n\nggplot() +\n  geom_sf(data = hartford, fill = 'grey90', color = 'white') +\n  geom_sf(data = robbery, color = \"#EE6677\", size = 1, alpha = .3) +\n  geom_sf(data = sim_gas_points, color = \"#4477AA\", size = 2) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![Observed robberies and simulated gas station locations](spatial-sim_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Pairwise Simulation\n\nNaturally, it makes sense to use simulations of both robberies *and* gas stations to create our simulated crime and location data. We should check the cross-K function between our simulated gas stations and simulated robberies. In these cases it is often easier to assess this by performing a transformation of the K function to the variance-stabilized L function. If we subtract the distance at each value of L we get the L-cross - r which is a handy way to visualize a point process.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute observed L-function\ngas_robbery_cross <-\n  sf_to_multitype(\n    window = hartford,\n    i = robbery,\n    j = gas,\n    i_name = \"robbery\",\n    j_name = \"gas\"\n  )\n\ngas_robbery_lest <- Lcross(gas_robbery_cross, i = \"gas\", j = \"robbery\", r = gas_kest$r,  correction = \"border\")\n\nobs_L <- data.frame(r = gas_robbery_lest$r,\n                    L = gas_robbery_lest$border) %>%\n  mutate(L = L-r)\n\n\n# gather simulations, plot L function\nsim_list <- lapply(gas_sim, sp_to_sf, crs = st_crs(gas))\nsim_list2 <- lapply(robbery_sim, sp_to_sf, crs = st_crs(gas))\n\nsim_cross_list <- list()\n\nfor(sim in 1:N_SIM){\n  sim_cross_points <-\n    sf_to_multitype(\n      window = hartford,\n      i = sim_list2[[sim]],\n      j = sim_list[[sim]],\n      i_name = \"robbery\",\n      j_name = \"gas\"\n    )\n  sim_cross_list[[sim]] <- sim_cross_points\n}\n\n\n# compute lcross border corrected\nlcross_list <- lapply(sim_cross_list, Lcross, i = \"gas\", j = \"robbery\", r = gas_kest$r,  correction = \"border\")\n\n# plot envelopes against observed\nX_l <- sapply(lcross_list, function(x){x$border})\n\nX_ldf <- as.data.frame(X_l)\nX_ldf$r <- gas_kest$r\n\n\n# plot \nX_ldf %>%\n  pivot_longer(-r, names_to = \"simulation\", values_to = \"L\") %>%\n  mutate(L = L-r) %>%\n  group_by(r) %>%\n  summarise(Lmin = min(L),\n            Lmax = max(L)) %>%\n  ggplot() +\n  geom_ribbon(aes(x = r, ymin = Lmin, ymax = Lmax), alpha = .3) +\n  geom_line(data = obs_L, aes(x = r, y = L), linewidth = 1, color = 'red') + \n  geom_hline(yintercept = 0) +\n  labs(y = 'L-r(Border)', x = 'Distance (feet)') +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![100 Simulation envelopes (grey) compared to observed L-r (red)](spatial-sim_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nAnd this is why it is important to check. We can clearly see that while our simulated data is fairly close to the observed pattern for most distances 1000 feet and beyond, there is much *less* clustering at small spatial scales. This makes sense, because of how crime is often geo-coded. When you have crimes that occur directly on the location they will typically share the same coordinates. In our case, our points are more spread out than we would expect to see in real life. \n\nWhether or not this data is \"good enough\" will depend on the use case at hand. In many cases very rough synthetic data can suffice for many purposes. In other cases, where high-fidelity synthetic data is needed, considerably more post-processing is required to bring the synthetic data in line with the real.",
    "supporting": [
      "spatial-sim_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}